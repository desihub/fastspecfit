#!/usr/bin/env python

'''Build a set of templates for use with FastSpecFit.

* Chabrier IMF
* MIST isochrones
* C3K_a stellar library
* 7 variable-width age bins between 30 Myr and 13.7 Gyr with constant star
  formation within each age bin
* 3 stellar metallicity values between -1 and 0.3 (relative to solar)

Note that Figure 3 in Leja et al. 2017 nicely shows the effect of various
free parameters on the resulting SED.

conda activate fastspecfit
time python $HOME/code/desihub/fastspecfit/bin/new-fsps-templates --imf chabrier --version 2.0.0

Note: to use different stellar libraries (e.g., MILES vs C3K), in a clean
terminal make sure you've git-updated a local checkout of the python-fsps and
that $SPS_HOME/src/sps_vars.f90 has been edited correctly and then:

% echo SPS_HOME
  /Users/ioannis/code/python-fsps/src/fsps/libfsps
% python -m pip install . --no-cache-dir --force-reinstall
% python -c "import fsps; sp = fsps.StellarPopulation(); print(sp.libraries)"

'''
import os, time, pdb
import numpy as np
import argparse
import fitsio, fsps
from scipy.ndimage import gaussian_filter1d
from scipy.integrate import simpson

from astropy.io import fits
from astropy.table import Table
import matplotlib.pyplot as plt

from desispec.interpolation import resample_flux
from fastspecfit.util import C_LIGHT
from fastspecfit.continuum import PIXKMS_BLU, PIXKMS_RED, PIXKMS_WAVESPLIT

irfactor = int(PIXKMS_RED / PIXKMS_BLU)

templatedir = os.path.join(os.environ.get('DESI_ROOT'), 'science', 'gqp', 'templates', 'fastspecfit')


def build_dustem_templates(qpah=3.5, umin=1., gamma=0.01, png=None):
    """Build the DL07 dust emission templates.

    """
    from scipy.interpolate import RegularGridInterpolator

    # Umin and qpah parameter grids
    umin_grid = np.array([0.10, 0.15, 0.20, 0.30, 0.40, 0.50, 0.70, 0.80,
                          1.00, 1.20, 1.50, 2.00, 2.50, 3.00, 4.00, 5.00, 
                          7.00, 8.00, 12.0, 15.0, 20.0, 25.0])
    numin = len(umin_grid)

    # from Table 3 in https://arxiv.org/pdf/astro-ph/0608003
    d_qpah = {
        'MW3.1_00': 0.47,
        'MW3.1_10': 1.12,
        'MW3.1_20': 1.77,
        'MW3.1_30': 2.50,
        'MW3.1_40': 3.19,
        'MW3.1_50': 3.90,
        'MW3.1_60': 4.58,
        }
    models = list(d_qpah.keys())
    qpah_grid = np.array([d_qpah[model] for model in models])
    nqpah = len(qpah_grid)

    nwave = 1001 # fixed number of wavelengths
    dustem = np.zeros((nqpah, numin*2, nwave))

    for imodel, model in enumerate(models):
        dustfile = os.path.join(templatedir, 'original', f'DL07_{model}.dat')
        dustem1 = np.loadtxt(dustfile, skiprows=2)
        if imodel == 0:
            wave = dustem1[:, 0]
        dustem[imodel, :, :] = dustem1[:, 1:].T
    wave *= 1e4 # [mu --> Angstrom]

    # set up the interpolation objects
    umin_interp = RegularGridInterpolator((qpah_grid, umin_grid), dustem[:, :22, :])
    umax_interp = RegularGridInterpolator((qpah_grid, umin_grid), dustem[:, 22:, :])

    dumin = umin_interp((qpah, umin))
    dumax = umax_interp((qpah, umin))
    dustem = (1. - gamma) * dumin + gamma * dumax

    # convert to per A (from per Hz) and normalize to unity
    dustem /= wave**2
    dustem /= simpson(dustem, x=wave)

    if png:
        fig, ax = plt.subplots()
        #I = np.where(wave/1e4 < 10.)[0]
        I = np.arange(len(wave))
        ax.plot(wave[I], dustem, label='umin={umin:.1f} qpah={qpah:.2f} gamma={gamma:.2f}')
        #ax.plot(wave[I], dustem[4, 8, I], label='model: qpah=3.19')
        #ax.plot(wave[I], dustem[5, 8, I], label='model: qpah=3.90')
        #ax.plot(wave[I], dumin[I], label='interp: qpah=3.5')
        ax.set_xscale('log')
        ax.set_yscale('log')
        ax.legend()
        fig.tight_layout()
        fig.savefig(png)

    return wave, dustem


def build_agn_templates(agntau=10.):
    """Build the AGN templates.

    """

    pdb.set_trace()
    
    

def build_fsps_templates(models, logages, agebins=None, imf='chabrier',
                         include_nebular=True):

    nsed = len(models)

    meta = Table()
    meta['age'] = 10**models['logage']
    meta['zzsun'] = models['logmet']
    meta['mstar'] = np.zeros(nsed, 'f4')
    meta['sfr'] = np.zeros(nsed, 'f4')

    # https://dfm.io/python-fsps/current/stellarpop_api/
    imfdict = {'salpeter': 0, 'chabrier': 1, 'kroupa': 2}

    print('Instantiating the StellarPopulation object...', end='')
    t0 = time.time()
    # tabular SFH
    sp = fsps.StellarPopulation(
        compute_vega_mags=False, 
        add_dust_emission=False, # note!
        add_neb_emission=True,
        nebemlineinspec=include_nebular,
        imf_type=imfdict[imf],
        #dust_type=0,
        #dust_index=-0.7,
        sfh=3,  # tabular SFH parameters
        zcontinuous=1,
    )
    print('...took {:.3f} sec'.format((time.time()-t0)))
    print(sp.libraries)

    if include_nebular:
        print('Creating {} model spectra with nebular emission...'.format(nsed), end='')
    else:
        print('Creating {} model spectra without nebular emission...'.format(nsed), end='')

    t0 = time.time()
    for imodel, model in enumerate(models):
        sp.params['logzsol'] = model['logmet']

        # lookback time of constant SFR
        agebin_indx = np.where(model['logage'] == np.float32(logages))[0]
        agebin = agebins[agebin_indx, :][0] # Gyr
        fspstime = agebin - agebin[0]       # Gyr
        tage = agebin[1] # time of observation [Gyr] 
        #print(tage, model['logage'])

        dt = np.diff(agebin) * 1e9          # [yr]
        sfh = np.zeros_like(fspstime) + 1. / dt #/ 2 # [Msun/yr]

        # force the SFR to go to zero at the edge
        fspstime = np.hstack((fspstime, fspstime[-1]+1e-8))
        sfh = np.hstack((sfh, 0.))

        sp.set_tabular_sfh(fspstime, sfh)
        #print(tage, sp.sfr)

        wave, flux = sp.get_spectrum(tage=tage, peraa=True) # tage in Gyr

        #plt.clf()
        #I = (wave > 3500) * (wave < 9000)
        #plt.plot(wave[I], flux[I])
        #plt.savefig('junk2.png')
        #pdb.set_trace()

        lodot = 3.828e33 # [erg/s]
        tenpc2 = (10. * 3.085678e18)**2 # [cm^2]
    
        flux = flux * lodot / (4. * np.pi * tenpc2) # [erg/s/cm2/A/Msun at 10pc]

        # Resample to constant log-lambda / velocity. In the IR (starting at ~1
        # micron), take every fourth sampling, to save space.
        if imodel == 0:
            dlogwave = PIXKMS_BLU / C_LIGHT / np.log(10) # pixel size [log-lambda]
            newwave = 10**np.arange(np.log10(np.min(wave)), np.log10(np.max(wave)), dlogwave)
    
            isplit = np.argmin(np.abs(newwave-PIXKMS_WAVESPLIT)) + 1
            newwave = np.hstack((newwave[:isplit], newwave[isplit:][::irfactor]))
            npix = len(newwave)
    
            fluxes = np.zeros((npix, nsed), dtype=np.float32)

            # emission lines
            linewaves = sp.emline_wavelengths
            linefluxes = np.zeros((len(sp.emline_wavelengths), nsed), dtype=np.float32)

        newflux = resample_flux(newwave, wave, flux)
    
        fluxes[:, imodel] = newflux
        linefluxes[:, imodel] = sp.emline_luminosity * lodot / (4.0 * np.pi * tenpc2)

        meta['mstar'][imodel] = sp.stellar_mass
        meta['sfr'][imodel] = sp.sfr
        #print(tage, sp.formed_mass, sp.stellar_mass)
        if sp.stellar_mass < 0:
            raise ValueError('Stellar mass is negative!')

        #plt.clf()
        #I = np.where((wave > 3500) * (wave < 5600))[0]
        #J = np.where((newwave > 3500) * (newwave < 3600))[0]
        #plt.plot(wave[I], flux[I])
        #plt.plot(newwave[J], fluxes[J, imodel])
        #plt.savefig('junk.png')
        #pdb.set_trace()

    print('...took {:.3f} min'.format((time.time()-t0)/60))

    return meta, newwave, fluxes, linewaves, linefluxes


def fsps(imf='chabrier', qpah=3.5, umin=1., gamma=0.01, 
         agntau=10., test=False, version='1.0.0'):
    """Build all the templates.


    """
    # dust emission templates
    dustwave, dustem = build_dustem_templates(qpah=qpah, umin=umin, gamma=gamma, png='junk.png')

    pdb.set_trace()

    # Choose lookback time bins. 

    # from prospect.templates.adjust_continuity_agebins
    nbins = 5
    tuniv = 13.7
    tbinmax = (tuniv * 0.85) * 1e9
    lim1, lim2 = 7.4772, 8.0
    agelims = np.array([0, lim1] + np.linspace(lim2, np.log10(tbinmax), nbins-2).tolist() + [np.log10(tuniv*1e9)]) # log10(yr)
    agelims = 10.**agelims / 1e9 # [Gyr]

    agebins = np.array([agelims[:-1], agelims[1:]]).T # [Gyr]
    logages = np.log10(1e9*np.sum(agebins, axis=1) / 2) # mean age [log10(yr)] in each bin
    print('<Ages>: '+' '.join(['{:.4f} Gyr'.format(10.**logage/1e9) for logage in logages]))

    nages = len(logages)

    logmets = np.array([0.0]) # [-1.0, -0.3, 0.0, 0.3]
    #logmets = np.array([-1.0, 0.0, 0.3]) # [-1.0, -0.3, 0.0, 0.3]
    nmets = len(logmets)
    zsolar = 0.019

    # for testing
    if test:
        logmets = [0.0]
        nmets = 1
    
    dims = (nages, nmets)

    models_dtype = np.dtype(
        [('logmet', np.float32),
         ('logage', np.float32)])

    # Let's be pedantic about the procedure so we don't mess up the indexing...
    models = np.zeros(dims, dtype=models_dtype)

    for iage, logage in enumerate(logages):
        for imet, logmet in enumerate(logmets):
            models[iage, imet]['logmet'] = logmet
            models[iage, imet]['logage'] = logage

    models = models.flatten()

    # Build models with and without line-emission.
    meta, wave, flux, linewaves, linefluxes = build_fsps_templates(
        models, logages, agebins=agebins, include_nebular=True, 
        imf=imf)

    pdb.set_trace()

    _, _, fluxnolines, _, _ = build_fsps_templates(
        models, logages, agebins=agebins, include_nebular=False, 
        imf=imf)

    lineflux = flux - fluxnolines

    #I = (wave > 3500) * (wave < 9000)
    #plt.clf()
    #plt.plot(wave[I], flux[I, 0])
    #plt.plot(wave[I], fluxnolines[I, 0])
    #plt.ylim(0, 0.1e-7)
    #plt.savefig('junk2.png')
    #pdb.set_trace()

    # Build the velocity dispersion templates.

    # Select just the line-free models trimmed to the 1200-10000 A wavelength
    # range.
    I = np.where((wave > 1200) * (wave < PIXKMS_WAVESPLIT))[0]
    vdispwave = wave[I]
    #nvdispmodel = len(J)

    vdispflux = []
    for sigma in vdisp / PIXKMS_BLU:
        vdispflux.append(gaussian_filter1d(fluxnolines[I, :], sigma=sigma, axis=0))
    vdispflux = np.stack(vdispflux, axis=-1) # [npix,nvdispmodel,nvdisp]

    #K = np.where((vdispwave > 3500) * (vdispwave < 4300))[0]
    #plt.clf()
    #plt.plot(vdispwave[K], fluxnolines[I, 6][J])
    #plt.plot(vdispwave[K], vdispflux[J, 6, nvdisp-1])
    #plt.savefig('junk.png')
    #pdb.set_trace()

    # Write out.
    outdir = os.path.join(templatedir, version)
    if not os.path.isdir(outdir):
        os.makedirs(outdir, exist_ok=True)
    outfile = os.path.join(outdir, f'ftemplates-{imf}-{version}.fits')

    hduflux1 = fits.PrimaryHDU(flux)
    hduflux1.header['EXTNAME'] = 'FLUX'
    hduflux1.header['VERSION'] = version
    hduflux1.header['BUNIT'] = 'erg/(s cm2 Angstrom)'

    hduflux2 = fits.ImageHDU(lineflux)
    hduflux2.header['EXTNAME'] = 'LINEFLUX'
    hduflux2.header['VERSION'] = version
    hduflux2.header['BUNIT'] = 'erg/(s cm2 Angstrom)'

    hduflux3 = fits.ImageHDU(vdispflux)
    hduflux3.header['EXTNAME'] = 'VDISPFLUX'
    hduflux3.header['VERSION'] = version
    hduflux3.header['VDISPMIN'] = (vdispmin, 'minimum velocity dispersion [km/s]')
    hduflux3.header['VDISPMAX'] = (vdispmax, 'maximum velocity dispersion [km/s]')
    hduflux3.header['VDISPRES'] = (dvdisp, 'velocity dispersion spacing [km/s]')
    hduflux3.header['VDISPNOM'] = (vdisp_nominal, 'nominal (default) velocity dispersion [km/s]')
    hduflux3.header['BUNIT'] = 'erg/(s cm2 Angstrom)'

    isplit = np.argmin(np.abs(wave-PIXKMS_WAVESPLIT)) + 1

    hduwave1 = fits.ImageHDU(wave)
    hduwave1.header['EXTNAME'] = 'WAVE'
    hduwave1.header['BUNIT'] = 'Angstrom'
    hduwave1.header['AIRORVAC'] = ('vac', 'vacuum wavelengths')
    hduwave1.header['PIXSZBLU'] = (PIXKMS_BLU, 'pixel size blueward of PIXSZSPT [km/s]')
    hduwave1.header['PIXSZRED'] = (PIXKMS_RED, 'pixel size redward of PIXSZSPT [km/s]')
    hduwave1.header['PIXSZSPT'] = (wave[isplit], 'wavelength where pixel size changes [Angstrom]')

    hduwave2 = fits.ImageHDU(vdispwave)
    hduwave2.header['EXTNAME'] = 'VDISPWAVE'
    hduwave2.header['BUNIT'] = 'Angstrom'
    hduwave2.header['AIRORVAC'] = ('vac', 'vacuum wavelengths')
    hduwave2.header['PIXSZ'] = (PIXKMS_BLU, 'pixel size [km/s]')

    hdutable = fits.convenience.table_to_hdu(meta)
    hdutable.header['EXTNAME'] = 'METADATA'
    hdutable.header['imf'] = imf

    # emission lines
    hduflux4 = fits.ImageHDU(linefluxes)
    hduflux4.header['EXTNAME'] = 'LINEFLUXES'
    hduflux4.header['VERSION'] = version
    hduflux4.header['BUNIT'] = 'erg/(s cm2 Angstrom)'

    hduwave3 = fits.ImageHDU(linewaves)
    hduwave3.header['EXTNAME'] = 'LINEWAVES'
    hduwave3.header['BUNIT'] = 'Angstrom'
    hduwave3.header['AIRORVAC'] = ('vac', 'vacuum wavelengths')

    hx = fits.HDUList([hduflux1, hduflux2, hduwave1, hduflux3, hduwave2, hdutable, hduflux4, hduwave3])

    print(f'Writing {len(models)} model spectra to {outfile}')
    hx.writeto(outfile, overwrite=True)

if __name__ == '__main__':

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--version', required=True, help='Version number (e.g., 2.0.0)')

    # DL07 parameters
    # https://python-fsps.readthedocs.io/en/latest/stellarpop_api
    parser.add_argument('--qpah', type=float, default=3.5, help='DL07 parameter')
    parser.add_argument('--umin', type=float, default=1., help='DL07 parameter')
    parser.add_argument('--gamma', type=float, default=0.01, help='DL07 parameter')

    # Nenkova+08 parameters
    # https://python-fsps.readthedocs.io/en/latest/stellarpop_api
    parser.add_argument('--agntau', type=float, default=10., help='Nenkova+08 parameter')

    parser.add_argument('--imf', type=str, default='chabrier', choices=['chabrier', 'salpeter', 'kroupa'],
                        help='Initial mass function')
    parser.add_argument('--test', action='store_true', help='Generate a test set of SPS models.')
    args = parser.parse_args()

    fsps(imf=args.imf, qpah=args.qpah, umin=args.umin, gamma=args.gamma, 
         agntau=args.agntau, test=args.test, version=args.version)


